import pygame
import random
import sys
from pygame.locals import *

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 700
GRID_SIZE = 30
GRID_WIDTH = 10
GRID_HEIGHT = 20
SIDEBAR_WIDTH = 200

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GRAY = (128, 128, 128)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 120, 255)
CYAN = (0, 255, 255)
MAGENTA = (255, 0, 255)
YELLOW = (255, 255, 0)
ORANGE = (255, 165, 0)

SHAPES = [
    [[1, 1, 1, 1]],
    [[1, 1], [1, 1]],
    [[1, 1, 1], [0, 1, 0]],
    [[1, 1, 1], [1, 0, 0]],
    [[1, 1, 1], [0, 0, 1]],
    [[0, 1, 1], [1, 1, 0]],
    [[1, 1, 0], [0, 1, 1]]
]

SHAPE_COLORS = [CYAN, YELLOW, MAGENTA, ORANGE, BLUE, GREEN, RED]

class Tetromino:
    def init(self, x, y):
        self.x = x
        self.y = y
        self.shape_idx = random.randint(0, len(SHAPES) - 1)
        self.shape = SHAPES[self.shape_idx]
        self.color = SHAPE_COLORS[self.shape_idx]
        self.rotation = 0
        
    def rotate(self):
        rows = len(self.shape)
        cols = len(self.shape[0])
        rotated = [[0 for _ in range(rows)] for _ in range(cols)]
        
        for r in range(rows):
            for c in range(cols):
                rotated[c][rows - 1 - r] = self.shape[r][c]
        
        return rotated
    
    def get_positions(self):
        positions = []
        for r, row in enumerate(self.shape):
            for c, cell in enumerate(row):
                if cell:
                    positions.append((self.x + c, self.y + r))
        return positions

class TetrisGame:
    def init(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Tetris")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont(None, 36)
        self.small_font = pygame.font.SysFont(None, 24)
        
        self.reset_game()
        
    def reset_game(self):
        self.grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
        self.current_piece = self.new_piece()
        self.next_piece = self.new_piece()
        self.game_over = False
        self.score = 0
        self.level = 1
        self.lines_cleared = 0
        self.fall_speed = 0.5
        self.fall_time = 0
        
    def new_piece(self):
        return Tetromino(GRID_WIDTH // 2 - 1, 0)
    
    def valid_move(self, piece, x_offset=0, y_offset=0, shape=None):
        if shape is None:
            shape = piece.shape
            
        for r, row in enumerate(shape):
            for c, cell in enumerate(row):
                if cell:
                    new_x = piece.x + c + x_offset
                    new_y = piece.y + r + y_offset
                    
                    if (new_x < 0 or new_x >= GRID_WIDTH or 
                        new_y >= GRID_HEIGHT):
                        return False
                    
                    if new_y >= 0 and self.grid[new_y][new_x]:
                        return False
        return True
    
    def merge_piece(self):
        for x, y in self.current_piece.get_positions():
            if y >= 0:
                self.grid[y][x] = self.current_piece.color
    
    def clear_lines(self):
        lines_to_clear = []
        for y in range(GRID_HEIGHT):
            if all(self.grid[y]):
                lines_to_clear.append(y)
        
        for line in lines_to_clear:
            del self.grid[line]
            self.grid.insert(0, [0 for _ in range(GRID_WIDTH)])
        
        if lines_to_clear:
            self.lines_cleared += len(lines_to_clear)
            self.score += (1, 2, 5, 10)[min(len(lines_to_clear)-1, 3)] * 100 * self.level
            self.level = self.lines_cleared // 10 + 1
            self.fall_speed = max(0.05, 0.5 - (self.level - 1) * 0.05)
    
    def draw_grid(self):
        grid_left = (SCREEN_WIDTH - SIDEBAR_WIDTH - GRID_WIDTH * GRID_SIZE) // 2
        grid_top = (SCREEN_HEIGHT - GRID_HEIGHT * GRID_SIZE) // 2
        
        for y in range(GRID_HEIGHT + 1):
            pygame.draw.line(self.screen, GRAY,
(grid_left, grid_top + y * GRID_SIZE),
                           (grid_left + GRID_WIDTH * GRID_SIZE, grid_top + y * GRID_SIZE))
        
        for x in range(GRID_WIDTH + 1):
            pygame.draw.line(self.screen, GRAY,
                           (grid_left + x * GRID_SIZE, grid_top),
                           (grid_left + x * GRID_SIZE, grid_top + GRID_HEIGHT * GRID_SIZE))
        
        for y in range(GRID_HEIGHT):
            for x in range(GRID_WIDTH):
                if self.grid[y][x]:
                    pygame.draw.rect(self.screen, self.grid[y][x],
                                   (grid_left + x * GRID_SIZE + 1,
                                    grid_top + y * GRID_SIZE + 1,
                                    GRID_SIZE - 2, GRID_SIZE - 2))
        
        for x, y in self.current_piece.get_positions():
            if y >= 0:
                pygame.draw.rect(self.screen, self.current_piece.color,
                               (grid_left + x * GRID_SIZE + 1,
                                grid_top + y * GRID_SIZE + 1,
                                GRID_SIZE - 2, GRID_SIZE - 2))
                
                pygame.draw.rect(self.screen, WHITE,
                               (grid_left + x * GRID_SIZE + 1,
                                grid_top + y * GRID_SIZE + 1,
                                GRID_SIZE - 2, GRID_SIZE - 2), 1)
        
        pygame.draw.rect(self.screen, WHITE,
                        (grid_left - 2, grid_top - 2,
                         GRID_WIDTH * GRID_SIZE + 4, GRID_HEIGHT * GRID_SIZE + 4), 2)
        
        return grid_left, grid_top
    
    def draw_sidebar(self, grid_left):
        sidebar_left = grid_left + GRID_WIDTH * GRID_SIZE + 20
        
        next_text = self.font.render("Следующая:", True, WHITE)
        self.screen.blit(next_text, (sidebar_left, 100))
        
        next_piece_width = len(self.next_piece.shape[0]) * GRID_SIZE
        next_piece_height = len(self.next_piece.shape) * GRID_SIZE
        next_x = sidebar_left + (SIDEBAR_WIDTH - next_piece_width) // 2
        next_y = 150
        
        for r, row in enumerate(self.next_piece.shape):
            for c, cell in enumerate(row):
                if cell:
                    pygame.draw.rect(self.screen, self.next_piece.color,
                                   (next_x + c * GRID_SIZE,
                                    next_y + r * GRID_SIZE,
                                    GRID_SIZE - 2, GRID_SIZE - 2))
        
        score_text = self.font.render(f"Счет: {self.score}", True, WHITE)
        level_text = self.font.render(f"Уровень: {self.level}", True, WHITE)
        lines_text = self.font.render(f"Линии: {self.lines_cleared}", True, WHITE)
        
        self.screen.blit(score_text, (sidebar_left, 250))
        self.screen.blit(level_text, (sidebar_left, 300))
        self.screen.blit(lines_text, (sidebar_left, 350))
        
        controls = [
            "Управление:",
            "← → - Движение",
            "↑ - Поворот",
            "↓ - Ускорить",
            "Пробел - Сбросить",
            "P - Пауза",
            "ESC - Выход"
        ]
        
        for i, text in enumerate(controls):
            control_text = self.small_font.render(text, True, WHITE)
            self.screen.blit(control_text, (sidebar_left, 420 + i * 30))
    
    def draw_game_over(self):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        overlay.set_alpha(180)
        overlay.fill(BLACK)
        self.screen.blit(overlay, (0, 0))
        
        game_over_text = self.font.render("ИГРА ОКОНЧЕНА!", True, RED)
        restart_text = self.font.render("Нажмите ПРОБЕЛ для рестарта", True, WHITE)
        
        self.screen.blit(game_over_text, 
                        (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2, 
                         SCREEN_HEIGHT // 2 - 50))
        self.screen.blit(restart_text,
                        (SCREEN_WIDTH // 2 - restart_text.get_width() // 2,
                         SCREEN_HEIGHT // 2 + 20))
    
    def draw(self):
