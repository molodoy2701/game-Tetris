import pygame
import random
import sys

pygame.init()

SCREEN_WIDTH = 500
SCREEN_HEIGHT = 650
FPS = 60

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 50, 50)
GREEN = (50, 255, 50)
BLUE = (50, 100, 255)
YELLOW = (255, 255, 50)
PURPLE = (200, 50, 255)
CYAN = (50, 255, 255)
ORANGE = (255, 150, 50)

COLORS = [RED, GREEN, BLUE, YELLOW, PURPLE, CYAN, ORANGE]

SHAPES = [
    [[1, 1, 1],
     [0, 1, 0]],
    
    [[1, 1],
     [1, 1]],
    
    [[1, 1, 1, 1]],
    
    [[1, 1, 1],
     [1, 0, 0]],
    
    [[1, 1, 1],
     [0, 0, 1]],
    
    [[0, 1, 1],
     [1, 1, 0]],
    
    [[1, 1, 0],
     [0, 1, 1]]
]

GRID_WIDTH = 10
GRID_HEIGHT = 20
CELL_SIZE = 30
GRID_OFFSET_X = (SCREEN_WIDTH - GRID_WIDTH * CELL_SIZE) // 2
GRID_OFFSET_Y = 50

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Tetris")
clock = pygame.time.Clock()
font = pygame.font.SysFont('Arial', 36)
small_font = pygame.font.SysFont('Arial', 24)

class Tetromino:
    def __init__(self):
        self.shape_idx = random.randint(0, len(SHAPES) - 1)
        self.shape = [row[:] for row in SHAPES[self.shape_idx]]
        self.color = COLORS[self.shape_idx]
        self.x = GRID_WIDTH // 2 - len(self.shape[0]) // 2
        self.y = 0
    
    def rotate(self):
        rows = len(self.shape)
        cols = len(self.shape[0])
        rotated = [[0 for _ in range(rows)] for _ in range(cols)]
        
        for r in range(rows):
            for c in range(cols):
                rotated[c][rows - 1 - r] = self.shape[r][c]
        
        return rotated

def draw_grid(grid):
    for y in range(GRID_HEIGHT):
        for x in range(GRID_WIDTH):
            rect = pygame.Rect(
                GRID_OFFSET_X + x * CELL_SIZE,
                GRID_OFFSET_Y + y * CELL_SIZE,
                CELL_SIZE, CELL_SIZE
            )
            pygame.draw.rect(screen, (50, 50, 70), rect, 1)
            
            if grid[y][x]:
                pygame.draw.rect(screen, grid[y][x], rect.inflate(-2, -2))

def draw_piece(piece):
    for y, row in enumerate(piece.shape):
        for x, cell in enumerate(row):
            if cell:
                rect = pygame.Rect(
                    GRID_OFFSET_X + (piece.x + x) * CELL_SIZE,
                    GRID_OFFSET_Y + (piece.y + y) * CELL_SIZE,
                    CELL_SIZE, CELL_SIZE
                )
                pygame.draw.rect(screen, piece.color, rect.inflate(-2, -2))
                pygame.draw.rect(screen, WHITE, rect.inflate(-4, -4), 1)

def check_collision(grid, piece, dx=0, dy=0):
    for y, row in enumerate(piece.shape):
        for x, cell in enumerate(row):
            if cell:
                new_x = piece.x + x + dx
                new_y = piece.y + y + dy
                
                if new_x < 0 or new_x >= GRID_WIDTH:
                    return True
                if new_y >= GRID_HEIGHT:
                    return True
                if new_y >= 0 and grid[new_y][new_x]:
                    return True
    return False

def merge_piece(grid, piece):
    for y, row in enumerate(piece.shape):
        for x, cell in enumerate(row):
            if cell:
                grid_y = piece.y + y
                if 0 <= grid_y < GRID_HEIGHT:
                    grid[grid_y][piece.x + x] = piece.color

def clear_lines(grid):
    lines_cleared = 0
    y = GRID_HEIGHT - 1
    
    while y >= 0:
        if all(grid[y]):
            lines_cleared += 1
            for yy in range(y, 0, -1):
                grid[yy] = grid[yy-1][:]
            grid[0] = [0] * GRID_WIDTH
        else:
            y -= 1
    
    return lines_cleared

def draw_sidebar(score, level, next_piece):
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, (20, 150))
    
    level_text = font.render(f"Level: {level}", True, WHITE)
    screen.blit(level_text, (20, 200))
    
    next_text = font.render("Next:", True, WHITE)
    screen.blit(next_text, (20, 250))
    
    next_x = 50
    next_y = 300
    
    for y, row in enumerate(next_piece.shape):
        for x, cell in enumerate(row):
            if cell:
                rect = pygame.Rect(next_x + x * 20, next_y + y * 20, 18, 18)
                pygame.draw.rect(screen, next_piece.color, rect)
                pygame.draw.rect(screen, WHITE, rect, 1)
    
    controls = [
        "Controls:",
        "← → : Move",
        "↑ : Rotate",
        "↓ : Speed",
        "Space: Drop",
        "R: Restart",
        "ESC: Exit"
    ]
    
    for i, text in enumerate(controls):
        control_text = small_font.render(text, True, WHITE)
        screen.blit(control_text, (20, 400 + i * 30))

def main():
    grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
    current_piece = Tetromino()
    next_piece = Tetromino()
    score = 0
    level = 1
    fall_speed = 0.5
    fall_time = 0
    game_over = False
    
    while True:
        dt = clock.tick(FPS) / 1000.0
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                
                if event.key == pygame.K_r:
                    grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
                    current_piece = Tetromino()
                    next_piece = Tetromino()
                    score = 0
                    level = 1
                    fall_speed = 0.5
                    game_over = False
                
                if not game_over:
                    if event.key == pygame.K_LEFT:
                        if not check_collision(grid, current_piece, dx=-1):
                            current_piece.x -= 1
                    
                    if event.key == pygame.K_RIGHT:
                        if not check_collision(grid, current_piece, dx=1):
                            current_piece.x += 1
                    
                    if event.key == pygame.K_DOWN:
                        if not check_collision(grid, current_piece, dy=1):
                            current_piece.y += 1
                    
                    if event.key == pygame.K_UP:
                        rotated_shape = current_piece.rotate()
                        old_shape = current_piece.shape
                        current_piece.shape = rotated_shape
                        if check_collision(grid, current_piece):
                            current_piece.shape = old_shape
                    
                    if event.key == pygame.K_SPACE:
                        while not check_collision(grid, current_piece, dy=1):
                            current_piece.y += 1
                        fall_time = fall_speed
        
        if not game_over:
            fall_time += dt
            
            if fall_time >= fall_speed:
                if not check_collision(grid, current_piece, dy=1):
                    current_piece.y += 1
                    fall_time = 0
                else:
                    merge_piece(grid, current_piece)
                    
                    lines = clear_lines(grid)
                    if lines > 0:
                        score += lines * 100 * level
                        level = 1 + score // 1000
                        fall_speed = max(0.1, 0.5 - (level - 1) * 0.05)
                    
                    current_piece = next_piece
                    next_piece = Tetromino()
                    
                    if check_collision(grid, current_piece):
                        game_over = True
                    
                    fall_time = 0
        
        screen.fill(BLACK)
        
        pygame.draw.rect(screen, (40, 40, 60), 
                        (GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5,
                         GRID_WIDTH * CELL_SIZE + 10, GRID_HEIGHT * CELL_SIZE + 10))
        pygame.draw.rect(screen, WHITE, 
                        (GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5,
                         GRID_WIDTH * CELL_SIZE + 10, GRID_HEIGHT * CELL_SIZE + 10), 2)
        
        draw_grid(grid)
        draw_piece(current_piece)
        draw_sidebar(score, level, next_piece)
        
        title = font.render("TETRIS", True, CYAN)
        screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 10))
        
        if game_over:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            screen.blit(overlay, (0, 0))
            
            game_over_text = font.render("GAME OVER", True, RED)
            restart_text = font.render("Press R to restart", True, WHITE)
            
            screen.blit(game_over_text, 
                       (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2,
                        SCREEN_HEIGHT // 2 - 30))
            screen.blit(restart_text,
                       (SCREEN_WIDTH // 2 - restart_text.get_width() // 2,
                        SCREEN_HEIGHT // 2 + 20))
        
        pygame.display.flip()

if __name__ == "__main__":
    main()
